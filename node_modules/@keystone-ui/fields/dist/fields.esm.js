import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import { forwardRef, Fragment } from 'react';
import { useTheme, jsx, VisuallyHidden, forwardRefWithAs } from '@keystone-ui/core';
import ReactSelect from 'react-select';
export { components as selectComponents } from 'react-select';

/** @jsx jsx */
const ControlLabel = ({
  children,
  className,
  control,
  size: sizeKey = 'medium'
}) => {
  const {
    controlSizes,
    spacing,
    typography
  } = useTheme();
  const size = controlSizes[sizeKey];
  return jsx("label", {
    className: className,
    css: {
      alignItems: 'flex-start',
      display: 'inline-flex'
    }
  }, control, children && jsx("div", {
    css: {
      fontSize: size.fontSize,
      lineHeight: typography.leading.tight,
      marginLeft: spacing.small,
      paddingTop: spacing.xsmall,
      userSelect: 'none'
    }
  }, children));
};

/** @jsx jsx */

const Svg = ({
  children,
  size,
  stroke = 'none',
  fill = 'none'
}) => jsx("svg", {
  "aria-hidden": "true",
  focusable: "false",
  css: {
    verticalAlign: 'text-bottom',
    // removes whitespace inside buttons
    fill,
    stroke,
    strokeLinejoin: 'round',
    strokeLinecap: 'round',
    strokeWidth: 3
  },
  height: `${size}px`,
  width: `${size}px`,
  role: "img",
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, children);

const checkSizeMap = {
  small: 14,
  medium: 18,
  large: 24
};
const CheckIcon = ({
  size = 'medium'
}) => {
  return jsx(Svg, {
    size: checkSizeMap[size],
    stroke: "currentColor"
  }, jsx("polyline", {
    points: "20 6 10 18 4 12"
  }));
};
const dotSizeMap = {
  small: 12,
  medium: 16,
  large: 20
};
const DotIcon = ({
  size = 'medium'
}) => {
  return jsx(Svg, {
    size: dotSizeMap[size],
    fill: "currentColor"
  }, jsx("circle", {
    cx: "12",
    cy: "12",
    r: "8"
  }));
};

const useIndicatorTokens = ({
  size: sizeKey,
  type
}) => {
  const {
    controlSizes,
    fields
  } = useTheme();
  const size = controlSizes[sizeKey];
  return {
    background: fields.controlBackground,
    borderColor: fields.controlBorderColor,
    borderRadius: type === 'checkbox' ? fields.controlBorderRadius : '50%',
    borderWidth: fields.controlBorderWidth,
    boxSize: size.indicatorBoxSize,
    foreground: fields.controlBackground,
    // visually hide the icon unless the control is checked
    hover: {
      background: fields.hover.controlBackground,
      borderColor: fields.hover.controlBorderColor,
      shadow: fields.hover.shadow,
      foreground: fields.hover.controlForeground
    },
    focus: {
      background: fields.focus.controlBackground,
      borderColor: fields.focus.controlBorderColor,
      shadow: fields.focus.shadow,
      foreground: fields.focus.controlForeground
    },
    selected: {
      background: type === 'checkbox' ? fields.selected.controlBackground : fields.selected.controlForeground,
      borderColor: fields.selected.controlBorderColor,
      shadow: fields.selected.shadow,
      foreground: type === 'checkbox' ? fields.selected.controlForeground : fields.selected.controlBackground
    },
    disabled: {
      background: fields.disabled.controlBackground,
      borderColor: fields.disabled.controlBorderColor,
      shadow: fields.disabled.shadow,
      foreground: fields.disabled.controlForeground
    }
  };
};
const useIndicatorStyles = ({
  tokens
}) => {
  return {
    alignItems: 'center',
    backgroundColor: tokens.background,
    borderColor: tokens.borderColor,
    borderRadius: tokens.borderRadius,
    borderStyle: 'solid',
    borderWidth: tokens.borderWidth,
    boxSizing: 'border-box',
    color: tokens.foreground,
    cursor: 'pointer',
    display: 'flex',
    flexShrink: 0,
    height: tokens.boxSize,
    justifyContent: 'center',
    transition: tokens.transition,
    width: tokens.boxSize,
    'input:hover + &': {
      backgroundColor: tokens.hover.background,
      borderColor: tokens.hover.borderColor,
      boxShadow: tokens.hover.shadow,
      color: tokens.hover.foreground
    },
    'input:focus + &': {
      backgroundColor: tokens.focus.background,
      borderColor: tokens.focus.borderColor,
      boxShadow: tokens.focus.shadow,
      color: tokens.focus.foreground
    },
    'input:checked + &': {
      backgroundColor: tokens.selected.background,
      borderColor: tokens.selected.borderColor,
      boxShadow: tokens.selected.shadow,
      color: tokens.selected.foreground
    },
    'input:disabled + &': {
      backgroundColor: tokens.disabled.background,
      borderColor: tokens.disabled.borderColor,
      boxShadow: tokens.disabled.shadow,
      color: tokens.disabled.background,
      cursor: 'default'
    },
    'input:checked:disabled + &': {
      color: tokens.disabled.foreground
    }
  };
};

const Checkbox = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children,
    className,
    size
  } = _ref,
      props = _objectWithoutProperties(_ref, ["children", "className", "size"]);

  return jsx(ControlLabel, {
    className: className,
    size: size,
    control: jsx(CheckboxControl, _extends({
      ref: ref,
      size: size
    }, props))
  }, children);
});
const CheckboxControl = /*#__PURE__*/forwardRef((_ref2, ref) => {
  let {
    className,
    size
  } = _ref2,
      props = _objectWithoutProperties(_ref2, ["className", "size"]);

  return jsx(Fragment, null, jsx(VisuallyHidden, _extends({
    ref: ref,
    as: "input",
    type: "checkbox"
  }, props)), jsx(Indicator, {
    className: className,
    size: size
  }, jsx(CheckIcon, {
    size: size
  })));
});

const Indicator = (_ref3) => {
  let {
    className,
    size
  } = _ref3,
      props = _objectWithoutProperties(_ref3, ["className", "size"]);

  const tokens = useIndicatorTokens({
    type: 'checkbox',
    size: size || 'medium'
  });
  const styles = useIndicatorStyles({
    tokens
  });
  return jsx("div", _extends({
    className: className,
    css: styles
  }, props));
};

const FieldContainer = (_ref) => {
  let {
    children
  } = _ref,
      props = _objectWithoutProperties(_ref, ["children"]);

  return jsx("div", props, children);
};

const FieldLabel = forwardRefWithAs((_ref, ref) => {
  let {
    as: Tag = 'label',
    children
  } = _ref,
      props = _objectWithoutProperties(_ref, ["as", "children"]);

  const {
    typography,
    fields,
    spacing
  } = useTheme();
  return jsx(Tag, _extends({
    ref: ref,
    css: {
      color: fields.labelColor,
      display: 'block',
      fontWeight: typography.fontWeight.semibold,
      marginBottom: spacing.xsmall,
      minWidth: 120
    }
  }, props), children);
});

const FieldLegend = props => {
  const {
    typography,
    fields,
    spacing
  } = useTheme();
  return jsx("legend", _extends({
    css: {
      color: fields.legendColor,
      display: 'block',
      fontSize: typography.fontSize.small,
      fontWeight: typography.fontWeight.bold,
      marginBottom: spacing.xsmall,
      minWidth: 120,
      textTransform: 'uppercase'
    }
  }, props));
};

const Radio = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children,
    className,
    size
  } = _ref,
      props = _objectWithoutProperties(_ref, ["children", "className", "size"]);

  return jsx(ControlLabel, {
    className: className,
    size: size,
    control: jsx(RadioControl, _extends({
      ref: ref,
      size: size
    }, props))
  }, children);
});
const RadioControl = /*#__PURE__*/forwardRef((_ref2, ref) => {
  let {
    size
  } = _ref2,
      props = _objectWithoutProperties(_ref2, ["size"]);

  return jsx(Fragment, null, jsx(VisuallyHidden, _extends({
    ref: ref,
    as: "input",
    type: "radio"
  }, props)), jsx(Indicator$1, {
    size: size
  }, jsx(DotIcon, {
    size: size
  })));
});

const Indicator$1 = (_ref3) => {
  let {
    size
  } = _ref3,
      props = _objectWithoutProperties(_ref3, ["size"]);

  const tokens = useIndicatorTokens({
    type: 'radio',
    size: size || 'medium'
  });
  const styles = useIndicatorStyles({
    tokens
  });
  return jsx("div", _extends({
    css: styles
  }, props));
};

const Switch = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    children,
    className
  } = _ref,
      props = _objectWithoutProperties(_ref, ["children", "className"]);

  return jsx(ControlLabel, {
    className: className,
    control: jsx(SwitchControl, _extends({
      ref: ref
    }, props))
  }, children);
});
const SwitchControl = /*#__PURE__*/forwardRef((_ref2, ref) => {
  let {
    a11yLabels = {
      on: 'On',
      off: 'Off'
    },
    checked = false,
    onChange
  } = _ref2,
      props = _objectWithoutProperties(_ref2, ["a11yLabels", "checked", "onChange"]);

  let onClick = () => {
    if (onChange) {
      onChange(!checked);
    }
  };

  return jsx(Button, _extends({
    "aria-checked": checked,
    role: "switch",
    onClick: onClick,
    ref: ref
  }, props), jsx(VisuallyHidden, null, checked ? a11yLabels.on : a11yLabels.off));
});
const Button = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    animation,
    fields,
    sizing
  } = useTheme();
  let gutter = 3;
  let trackHeight = sizing.xsmall + gutter;
  let trackWidth = trackHeight * 2 - 2 * gutter;
  let handleSize = trackHeight - gutter * 2;
  return jsx("button", _extends({
    ref: ref,
    css: {
      backgroundColor: fields.controlBorderColor,
      borderRadius: 9999,
      padding: gutter,
      border: 0,
      boxSizing: 'border-box',
      display: 'block',
      outline: 0,
      overflow: 'hidden',
      position: 'relative',
      whiteSpace: 'nowrap',
      // height: trackHeight,
      width: trackWidth,
      cursor: 'pointer',
      '&[aria-checked="true"]': {
        backgroundColor: fields.selected.controlBorderColor,
        '::before': {
          transform: 'translateX(100%)'
        }
      },
      '::before': {
        height: handleSize,
        width: handleSize,
        marginTop: -1,
        backgroundColor: fields.switchForeground,
        borderRadius: '50%',
        content: '" "',
        display: 'block',
        position: 'relative',
        transition: `transform ${animation.duration400} ${animation.easeOut}`
      }
    }
  }, props));
});

const useInputTokens = ({
  size: sizeKey = 'medium',
  // width: widthKey = 'large',
  isMultiline = false,
  shape = 'square'
}) => {
  const {
    animation,
    controlSizes,
    fields,
    radii,
    spacing,
    typography
  } = useTheme(); // const width = widthMap[widthKey];

  const size = controlSizes[sizeKey];
  return {
    background: fields.inputBackground,
    borderColor: fields.inputBorderColor,
    borderRadius: shape === 'round' ? radii.full : fields.inputBorderRadius,
    borderWidth: fields.inputBorderWidth,
    fontSize: size.fontSize,
    foreground: fields.inputForeground,
    height: isMultiline ? undefined : size.height,
    lineHeight: isMultiline ? typography.leading.base : `${size.height}px`,
    paddingX: spacing.medium,
    paddingY: isMultiline ? spacing.small : 0,
    placeholder: fields.inputPlaceholder,
    shadow: fields.shadow,
    transition: `
      background-color ${animation.duration100},
      box-shadow ${animation.duration100},
      border-color ${animation.duration100}
    `,
    // width,
    hover: {
      background: fields.hover.inputBackground,
      borderColor: fields.hover.inputBorderColor,
      shadow: fields.hover.shadow,
      foreground: fields.hover.inputForeground
    },
    focus: {
      background: fields.focus.inputBackground,
      borderColor: fields.focus.inputBorderColor,
      shadow: fields.focus.shadow,
      foreground: fields.focus.inputForeground
    },
    invalid: {
      background: fields.invalid.inputBackground,
      borderColor: fields.invalid.inputBorderColor,
      shadow: fields.invalid.shadow,
      foreground: fields.invalid.inputForeground
    },
    disabled: {
      background: fields.disabled.inputBackground,
      borderColor: fields.disabled.inputBorderColor,
      shadow: fields.disabled.shadow,
      foreground: fields.disabled.inputForeground
    }
  };
};
function useInputStyles({
  invalid,
  tokens
}) {
  const styles = {
    appearance: 'none',
    backgroundColor: invalid ? tokens.invalid.background : tokens.background,
    borderColor: invalid ? tokens.invalid.borderColor : tokens.borderColor,
    borderRadius: tokens.borderRadius,
    borderStyle: 'solid',
    borderWidth: tokens.borderWidth,
    boxShadow: invalid ? tokens.invalid.shadow : tokens.shadow,
    boxSizing: 'border-box',
    color: invalid ? tokens.invalid.foreground : tokens.foreground,
    fontSize: tokens.fontSize,
    height: tokens.height,
    lineHeight: tokens.lineHeight,
    // maxWidth: tokens.width,
    outline: 0,
    paddingBottom: tokens.paddingY,
    paddingLeft: tokens.paddingX,
    paddingRight: tokens.paddingX,
    paddingTop: tokens.paddingY,
    resize: 'vertical',
    // applies to textarea
    transition: tokens.transition,
    width: '100%',
    ':hover': {
      backgroundColor: tokens.hover.background,
      borderColor: tokens.hover.borderColor,
      boxShadow: tokens.hover.shadow,
      color: tokens.hover.foreground
    },
    ':focus': {
      backgroundColor: tokens.focus.background,
      borderColor: tokens.focus.borderColor,
      boxShadow: tokens.focus.shadow,
      color: tokens.focus.foreground
    },
    ':disabled': {
      backgroundColor: tokens.disabled.background,
      borderColor: tokens.disabled.borderColor,
      boxShadow: tokens.disabled.shadow,
      color: tokens.disabled.foreground
    },
    '&::placeholder': {
      color: tokens.placeholder
    }
  };
  return styles;
}

const TextArea = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    invalid = false,
    size = 'medium',
    width = 'large'
  } = _ref,
      props = _objectWithoutProperties(_ref, ["invalid", "size", "width"]);

  const tokens = useInputTokens({
    size,
    width,
    shape: 'square',
    isMultiline: true
  });
  const styles = useInputStyles({
    invalid,
    tokens
  });
  return jsx("textarea", _extends({
    rows: 4,
    ref: ref,
    css: styles
  }, props));
});

const TextInput = /*#__PURE__*/forwardRef((_ref, ref) => {
  let {
    invalid = false,
    shape = 'square',
    size = 'medium',
    type = 'text',
    width = 'large'
  } = _ref,
      props = _objectWithoutProperties(_ref, ["invalid", "shape", "size", "type", "width"]);

  const tokens = useInputTokens({
    size,
    width,
    shape
  });
  const styles = useInputStyles({
    invalid,
    tokens
  });
  return jsx("input", _extends({
    ref: ref,
    type: type,
    css: styles
  }, props));
});

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const useStyles = ({
  tokens,
  multi = false
}) => {
  const {
    palette
  } = useTheme();

  const indicatorStyles = (provided, state) => _objectSpread2(_objectSpread2({}, provided), {}, {
    color: state.isFocused ? palette.neutral600 : palette.neutral500,
    ':hover': {
      color: state.isFocused ? palette.neutral800 : palette.neutral700
    }
  });

  return {
    control: (provided, state) => {
      const base = _objectSpread2(_objectSpread2({}, provided), {}, {
        backgroundColor: tokens.background,
        borderColor: tokens.borderColor,
        borderRadius: tokens.borderRadius,
        borderWidth: tokens.borderWidth,
        fontSize: tokens.fontSize,
        boxShadow: tokens.shadow,
        transition: tokens.transition
      });

      const variant = state.isDisabled ? {
        backgroundColor: tokens.disabled.background || tokens.background,
        borderColor: tokens.disabled.borderColor || tokens.borderColor,
        boxShadow: tokens.disabled.shadow || tokens.shadow,
        color: tokens.disabled.foreground || tokens.foreground
      } : state.isFocused ? {
        backgroundColor: tokens.focus.background || tokens.background,
        borderColor: tokens.focus.borderColor || tokens.borderColor,
        boxShadow: tokens.focus.shadow || tokens.shadow,
        color: tokens.focus.foreground || tokens.foreground
      } : {
        ':hover': {
          backgroundColor: tokens.hover.background,
          borderColor: tokens.hover.borderColor,
          boxShadow: tokens.hover.shadow,
          color: tokens.hover.foreground
        }
      };
      return _objectSpread2(_objectSpread2(_objectSpread2({}, provided), base), variant);
    },
    clearIndicator: indicatorStyles,
    dropdownIndicator: indicatorStyles,
    menu: provided => _objectSpread2(_objectSpread2({}, provided), {}, {
      border: `1px solid ${palette.neutral400}`,
      boxShadow: '0 4px 11px hsla(0, 0%, 0%, 0.1)',
      borderRadius: tokens.borderRadius,
      zIndex: 9999
    }),
    menuPortal: provided => _objectSpread2(_objectSpread2({}, provided), {}, {
      zIndex: 9999
    }),
    multiValue: provided => _objectSpread2(_objectSpread2({}, provided), {}, {
      backgroundColor: palette.neutral300,
      borderRadius: tokens.borderRadius
    }),
    multiValueLabel: provided => _objectSpread2(_objectSpread2({}, provided), {}, {
      // fontSize: typography.fontSize.medium,
      fontSize: '90%'
    }),
    multiValueRemove: provided => _objectSpread2(_objectSpread2({}, provided), {}, {
      borderRadius: tokens.borderRadius
    }),
    placeholder: provided => _objectSpread2(_objectSpread2({}, provided), {}, {
      color: tokens.placeholder
    }),
    valueContainer: provided => _objectSpread2(_objectSpread2({}, provided), {}, {
      padding: multi ? `0 4px` : `0 6px`
    })
  };
};

const portalTarget = typeof document !== 'undefined' ? document.body : undefined;
function Select(_ref) {
  let {
    onChange,
    value,
    width: widthKey = 'large',
    portalMenu
  } = _ref,
      props = _objectWithoutProperties(_ref, ["onChange", "value", "width", "portalMenu"]);

  const tokens = useInputTokens({
    width: widthKey
  });
  const styles = useStyles({
    tokens
  });
  return jsx(ReactSelect, _extends({
    value: value // css={{ width: tokens.width }}
    ,
    styles: styles,
    onChange: value => {
      if (!value) {
        onChange(null);
      } else {
        onChange(value);
      }
    }
  }, props, {
    isMulti: false,
    menuPortalTarget: portalMenu && portalTarget
  }));
}
function MultiSelect(_ref2) {
  let {
    onChange,
    value,
    width: widthKey = 'large',
    portalMenu
  } = _ref2,
      props = _objectWithoutProperties(_ref2, ["onChange", "value", "width", "portalMenu"]);

  const tokens = useInputTokens({
    width: widthKey
  });
  const styles = useStyles({
    tokens,
    multi: true
  });
  return jsx(ReactSelect // css={{ width: tokens.width }}
  , _extends({
    styles: styles,
    value: value,
    onChange: value => {
      if (!value) {
        onChange([]);
      } else if (Array.isArray(value)) {
        onChange(value);
      } else {
        onChange([value]);
      }
    }
  }, props, {
    isMulti: true,
    menuPortalTarget: portalMenu && portalTarget
  }));
}

export { Checkbox, CheckboxControl, FieldContainer, FieldLabel, FieldLegend, MultiSelect, Radio, Select, Switch, TextArea, TextInput, useIndicatorStyles, useIndicatorTokens, useInputStyles, useInputTokens };
