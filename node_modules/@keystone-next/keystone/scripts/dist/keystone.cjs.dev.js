'use strict';

require('../../dist/objectSpread2-a7e51403.cjs.dev.js');
require('@keystonejs/keystone');
require('@keystonejs/adapter-mongoose');
require('@keystonejs/adapter-knex');
require('@keystonejs/adapter-prisma');
require('@babel/runtime/helpers/objectWithoutProperties');
var graphql = require('graphql');
require('@graphql-tools/merge');
require('@graphql-tools/utils');
require('@graphql-tools/schema');
var system = require('@keystone-next/admin-ui/system');
require('../../dist/schema-b1ee2f14.cjs.dev.js');
var initConfig = require('../../dist/initConfig-42820b24.cjs.dev.js');
require('@keystonejs/server-side-graphql-client');
require('graphql/execution/values');
require('@keystone-next/fields');
require('cookie');
require('@hapi/iron');
require('uid-safe');
var session_dist_keystone = require('../../session/dist/keystone.cjs.dev.js');
var meow = require('meow');
var path = require('path');
var express = require('express');
var fs = require('fs-extra');
var prettier = require('prettier');
var pirates = require('pirates');
var babel = require('@babel/core');
var sourceMapSupport = require('source-map-support');
var cors = require('cors');
var apolloServerExpress = require('apollo-server-express');
var graphqlUpload = require('graphql-upload');
var formatError = require('@keystonejs/keystone/lib/Keystone/format-error');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var meow__default = /*#__PURE__*/_interopDefault(meow);
var path__default = /*#__PURE__*/_interopDefault(path);
var express__default = /*#__PURE__*/_interopDefault(express);
var prettier__default = /*#__PURE__*/_interopDefault(prettier);
var sourceMapSupport__default = /*#__PURE__*/_interopDefault(sourceMapSupport);
var cors__default = /*#__PURE__*/_interopDefault(cors);

/*
This is a slightly-modified version of preconstruct's hook for use with
keystone project files in the monorepo. Importantly it doesn't accept a cwd and
sets rootMode: "upward-optional"
*/
const EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx'];
const babelPlugins = [require.resolve('@babel/plugin-transform-modules-commonjs')];
const hook = () => {
  let compiling = false;
  let sourceMaps = {};
  let needsToInstallSourceMapSupport = true;

  function compileHook(code, filename) {
    if (compiling) return code; // we do this lazily because jest has its own require implementation
    // which means preconstruct's require hook won't be run
    // so we don't want to install source map support because that will mess up
    // jest's source map support

    if (needsToInstallSourceMapSupport) {
      sourceMapSupport__default['default'].install({
        environment: 'node',

        retrieveSourceMap(source) {
          let map = sourceMaps[source];

          if (map !== undefined) {
            return {
              url: source,
              map
            };
          } else {
            return null;
          }
        }

      });
      needsToInstallSourceMapSupport = false;
    }

    try {
      compiling = true;
      let output = babel.transformSync(code, {
        plugins: babelPlugins,
        filename,
        sourceMaps: 'both',
        rootMode: 'upward-optional'
      });
      sourceMaps[filename] = output.map;
      return output.code;
    } finally {
      compiling = false;
    }
  }

  return pirates.addHook(compileHook, {
    exts: EXTENSIONS
  });
};
const requireSource = filePath => {
  const unregister = hook();

  const result = require(filePath);

  unregister();
  return result;
};

const addApolloServer = ({
  server,
  graphQLSchema,
  createContext,
  sessionImplementation
}) => {
  const apolloServer = new apolloServerExpress.ApolloServer({
    uploads: false,
    schema: graphQLSchema,
    // FIXME: allow the dev to control where/when they get a playground
    playground: {
      settings: {
        'request.credentials': 'same-origin'
      }
    },
    formatError: formatError.formatError,
    // TODO: this needs to be discussed
    context: async ({
      req,
      res
    }) => createContext({
      sessionContext: await (sessionImplementation === null || sessionImplementation === void 0 ? void 0 : sessionImplementation.createSessionContext(req, res, createContext)),
      req
    }) // FIXME: support for apollo studio tracing
    // ...(process.env.ENGINE_API_KEY || process.env.APOLLO_KEY
    //   ? { tracing: true }
    //   : {
    //       engine: false,
    //       // Only enable tracing in dev mode so we can get local debug info, but
    //       // don't bother returning that info on prod when the `engine` is
    //       // disabled.
    //       tracing: dev,
    //     }),
    // FIXME: Support for generic custom apollo configuration
    // ...apolloConfig,

  }); // FIXME: Support custom API path via config.graphql.path.
  // Note: Core keystone uses '/admin/api' as the default.
  // FIXME: Support for file handling configuration
  // maxFileSize: 200 * 1024 * 1024,
  // maxFiles: 5,

  server.use(graphqlUpload.graphqlUploadExpress());
  apolloServer.applyMiddleware({
    app: server,
    path: '/api/graphql',
    cors: false
  });
};

const createExpressServer = async (config, system$1, dev) => {
  var _config$server;

  const server = express__default['default']();

  if ((_config$server = config.server) !== null && _config$server !== void 0 && _config$server.cors) {
    // Setting config.server.cors = true will provide backwards compatible defaults
    // Otherwise, the user can provide their own config object to use
    const corsConfig = typeof config.server.cors === 'boolean' ? {
      origin: true,
      credentials: true
    } : config.server.cors;
    server.use(cors__default['default'](corsConfig));
  }

  const sessionImplementation = config.session ? session_dist_keystone.implementSession(config.session()) : undefined;
  console.log('✨ Preparing GraphQL Server');
  const {
    graphQLSchema,
    createContext
  } = system$1;
  addApolloServer({
    server,
    graphQLSchema,
    createContext,
    sessionImplementation
  });
  console.log('✨ Preparing Next.js app');
  server.use(await system.createAdminUIServer(config.ui, system$1, dev, sessionImplementation));
  return server;
};

let printEnumTypeDefinition = node => {
  return `export type ${node.name.value} =\n${node.values.map(x => `  | ${JSON.stringify(x.name.value)}`).join('\n')};`;
};

function printInputTypesFromSchema(schema, schemaObj, scalars) {
  let ast = graphql.parse(schema);

  let printTypeNodeWithoutNullable = node => {
    if (node.kind === 'ListType') {
      return `ReadonlyArray<${printTypeNode(node.type)}>`;
    }

    let name = node.name.value;

    if (schemaObj.getType(name) instanceof graphql.GraphQLScalarType) {
      if (scalars[name] === undefined) {
        return 'any';
      }

      return `Scalars[${JSON.stringify(name)}]`;
    }

    return name;
  };

  let printTypeNode = node => {
    if (node.kind === 'NonNullType') {
      return printTypeNodeWithoutNullable(node.type);
    }

    return `${printTypeNodeWithoutNullable(node)} | null`;
  };

  let printInputObjectTypeDefinition = node => {
    var _node$fields;

    let str = `export type ${node.name.value} = {\n`;
    (_node$fields = node.fields) === null || _node$fields === void 0 ? void 0 : _node$fields.forEach(node => {
      str += `  readonly ${node.name.value}${node.type.kind === 'NonNullType' || node.defaultValue ? '' : '?'}: ${printTypeNode(node.type)};\n`;
    });
    str += '};';
    return str;
  };

  let typeString = 'type Scalars = {\n';

  for (let scalar in scalars) {
    typeString += `  readonly ${scalar}: ${scalars[scalar]};\n`;
  }

  typeString += '};';

  for (const node of ast.definitions) {
    if (node.kind === 'InputObjectTypeDefinition') {
      typeString += '\n\n' + printInputObjectTypeDefinition(node);
    }

    if (node.kind === 'EnumTypeDefinition') {
      typeString += '\n\n' + printEnumTypeDefinition(node);
    }
  }

  return {
    printedTypes: typeString + '\n',
    ast,
    printTypeNode
  };
}

function printGeneratedTypes(printedSchema, keystone, graphQLSchema) {
  let scalars = {
    ID: 'string',
    Boolean: 'boolean',
    String: 'string',
    Int: 'number',
    Float: 'number',
    JSON: 'import("@keystone-next/types").JSONValue'
  };
  let {
    printedTypes,
    ast,
    printTypeNode
  } = printInputTypesFromSchema(printedSchema, graphQLSchema, scalars);
  printedTypes += '\n';
  let allListsStr = '\nexport type KeystoneListsTypeInfo = {';
  let queryTypeName = graphQLSchema.getQueryType().name;
  let queryNode = ast.definitions.find(node => {
    return node.kind === 'ObjectTypeDefinition' && node.name.value === queryTypeName;
  });

  if (!queryNode) {
    throw new Error('Query type on GraphQL schema not found when generating types');
  }

  let queryNodeFieldsByName = {};

  for (const field of queryNode.fields) {
    queryNodeFieldsByName[field.name.value] = field;
  }

  let printArgs = args => {
    let types = '{\n';

    for (const arg of args) {
      if (arg.name.value === 'search' || arg.name.value === 'orderBy') continue;
      types += `  readonly ${arg.name.value}${arg.type.kind === 'NonNullType' || arg.defaultValue ? '' : '?'}: ${printTypeNode(arg.type)};\n`;
    }

    return types + '}';
  };

  for (const listKey in keystone.lists) {
    const list = keystone.lists[listKey];
    let backingTypes = '{\n';

    for (const field of list.fields) {
      for (const [key, {
        optional,
        type
      }] of Object.entries(field.getBackingTypes())) {
        backingTypes += `readonly ${JSON.stringify(key)}${optional ? '?' : ''}: ${type};\n`;
      }
    }

    backingTypes += '}';
    const {
      gqlNames
    } = list;
    let listTypeInfoName = `${listKey}ListTypeInfo`;
    printedTypes += `
export type ${listTypeInfoName} = {
  key: ${JSON.stringify(listKey)};
  fields: ${Object.keys(list.fieldsByPath).map(x => JSON.stringify(x)).join('|')}
  backing: ${backingTypes};
  inputs: {
    where: ${gqlNames.whereInputName};
    create: ${gqlNames.createInputName};
    update: ${gqlNames.updateInputName};
  };
  args: {
    listQuery: ${printArgs(queryNodeFieldsByName[gqlNames.listQueryName].arguments)}
  };
};

export type ${listKey}ListFn = (
  listConfig: import('@keystone-next/keystone/schema').ListConfig<${listTypeInfoName}, ${listTypeInfoName}['fields']>
) => import('@keystone-next/keystone/schema').ListConfig<${listTypeInfoName}, ${listTypeInfoName}['fields']>;
`;
    allListsStr += `\n  readonly ${JSON.stringify(listKey)}: ${listTypeInfoName};`;
  }

  return printedTypes + allListsStr + '\n};\n';
}

const CONFIG_PATH = path__default['default'].join(process.cwd(), 'keystone'); // TODO: Read port from config or process args

const PORT = process.env.PORT || 3000;

const devLoadingHTMLFilepath = path__default['default'].join(path__default['default'].dirname(require.resolve('@keystone-next/keystone/package.json')), 'src', 'static', 'dev-loading.html');
const formatSource = (src, parser = 'babel') => prettier__default['default'].format(src, {
  parser,
  trailingComma: 'es5',
  singleQuote: true
});
const dev = async () => {
  console.log('🤞 Starting Keystone');
  const server = express__default['default']();
  let expressServer = null;

  const initKeystone = async () => {
    const config = initConfig.initConfig(requireSource(CONFIG_PATH).default);
    const system$1 = initConfig.createSystem(config);
    let printedSchema = graphql.printSchema(system$1.graphQLSchema);
    console.log('✨ Generating Schema');
    await fs.outputFile('./.keystone/schema.graphql', printedSchema);
    await fs.outputFile('./.keystone/schema-types.ts', formatSource(printGeneratedTypes(printedSchema, system$1.keystone, system$1.graphQLSchema), 'babel-ts'));
    console.log('✨ Connecting to the Database');
    await system$1.keystone.connect();
    console.log('✨ Generating Admin UI');
    await system.generateAdminUI(config, system$1);
    expressServer = await createExpressServer(config, system$1, true);
    console.log(`👋 Admin UI Ready`);
  };

  server.use('/__keystone_dev_status', (req, res) => {
    res.json({
      ready: expressServer ? true : false
    });
  });
  server.use((req, res, next) => {
    if (expressServer) return expressServer(req, res, next);
    res.sendFile(devLoadingHTMLFilepath);
  });
  server.listen(PORT, err => {
    if (err) throw err;
    console.log(`⭐️ Dev Server Ready on http://localhost:${PORT}`); // Don't start initialising Keystone until the dev server is ready,
    // otherwise it slows down the first response significantly

    initKeystone().catch(err => {
      console.error(`🚨 There was an error initialising Keystone`);
      console.error(err);
      process.exit(1);
    });
  });
};

async function build() {
  const config = initConfig.initConfig(requireSource(CONFIG_PATH).default);
  const system$1 = initConfig.createSystem(config);
  let printedSchema = graphql.printSchema(system$1.graphQLSchema);
  console.log('✨ Generating Schema');
  await fs.outputFile('./.keystone/schema.graphql', printedSchema);
  await fs.outputFile('./.keystone/schema-types.ts', formatSource(printGeneratedTypes(printedSchema, system$1.keystone, system$1.graphQLSchema), 'babel-ts'));
  console.log('✨ Generating Admin UI');
  await system.generateAdminUI(config, system$1);
  console.log('✨ Building Admin UI and API');
  await system.buildAdminUI(path__default['default'].resolve('.keystone'));
}

const start = async () => {
  console.log('🤞 Starting Keystone');
  const apiFile = path__default['default'].resolve('./.keystone/admin/.next/server/pages/api/__keystone_api_build.js');

  if (!fs.existsSync(apiFile)) {
    throw new Error('keystone-next build must be run before running keystone-next start');
  }

  const config = initConfig.initConfig(require(apiFile).config);
  const system = initConfig.createSystem(config);
  console.log('✨ Connecting to the Database');
  await system.keystone.connect();
  const server = await createExpressServer(config, system, false);
  console.log(`👋 Admin UI Ready`);
  server.listen(PORT, err => {
    if (err) throw err;
    console.log(`⭐️ Server Ready on http://localhost:${PORT}`);
  });
};

const commands = {
  dev,
  build,
  start
};
function cli(input, helpText) {
  const command = input[0] || 'dev';

  if (!(command in commands)) {
    console.log(`${command} is not a command that keystone-next accepts`);
    console.log(helpText);
    process.exit(1);
  }

  commands[command]();
}

const {
  input,
  help
} = meow__default['default'](`
  Usage
    $ keystone-next [command]
  Commands
    dev          start the project in development mode
    build        build the project (must be done before using start)
    start        start the project in production mode
  `);
cli(input, help);
