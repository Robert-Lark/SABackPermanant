import '../../dist/objectSpread2-ff1b253c.esm.js';
import '@keystonejs/keystone';
import '@keystonejs/adapter-mongoose';
import '@keystonejs/adapter-knex';
import '@keystonejs/adapter-prisma';
import '@babel/runtime/helpers/objectWithoutProperties';
import { parse, GraphQLScalarType, printSchema } from 'graphql';
import '@graphql-tools/merge';
import '@graphql-tools/utils';
import '@graphql-tools/schema';
import { createAdminUIServer, generateAdminUI, buildAdminUI } from '@keystone-next/admin-ui/system';
import '../../dist/schema-15c288ef.esm.js';
import { i as initConfig, c as createSystem } from '../../dist/initConfig-53ee3fb9.esm.js';
import '@keystonejs/server-side-graphql-client';
import 'graphql/execution/values';
import '@keystone-next/fields';
import 'cookie';
import '@hapi/iron';
import 'uid-safe';
import { implementSession } from '../../session/dist/keystone.esm.js';
import meow from 'meow';
import path from 'path';
import express from 'express';
import { outputFile, existsSync } from 'fs-extra';
import prettier from 'prettier';
import { addHook } from 'pirates';
import { transformSync } from '@babel/core';
import sourceMapSupport from 'source-map-support';
import cors from 'cors';
import { ApolloServer } from 'apollo-server-express';
import { graphqlUploadExpress } from 'graphql-upload';
import { formatError } from '@keystonejs/keystone/lib/Keystone/format-error';

/*
This is a slightly-modified version of preconstruct's hook for use with
keystone project files in the monorepo. Importantly it doesn't accept a cwd and
sets rootMode: "upward-optional"
*/
const EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx'];
const babelPlugins = [require.resolve('@babel/plugin-transform-modules-commonjs')];
const hook = () => {
  let compiling = false;
  let sourceMaps = {};
  let needsToInstallSourceMapSupport = true;

  function compileHook(code, filename) {
    if (compiling) return code; // we do this lazily because jest has its own require implementation
    // which means preconstruct's require hook won't be run
    // so we don't want to install source map support because that will mess up
    // jest's source map support

    if (needsToInstallSourceMapSupport) {
      sourceMapSupport.install({
        environment: 'node',

        retrieveSourceMap(source) {
          let map = sourceMaps[source];

          if (map !== undefined) {
            return {
              url: source,
              map
            };
          } else {
            return null;
          }
        }

      });
      needsToInstallSourceMapSupport = false;
    }

    try {
      compiling = true;
      let output = transformSync(code, {
        plugins: babelPlugins,
        filename,
        sourceMaps: 'both',
        rootMode: 'upward-optional'
      });
      sourceMaps[filename] = output.map;
      return output.code;
    } finally {
      compiling = false;
    }
  }

  return addHook(compileHook, {
    exts: EXTENSIONS
  });
};
const requireSource = filePath => {
  const unregister = hook();

  const result = require(filePath);

  unregister();
  return result;
};

const addApolloServer = ({
  server,
  graphQLSchema,
  createContext,
  sessionImplementation
}) => {
  const apolloServer = new ApolloServer({
    uploads: false,
    schema: graphQLSchema,
    // FIXME: allow the dev to control where/when they get a playground
    playground: {
      settings: {
        'request.credentials': 'same-origin'
      }
    },
    formatError,
    // TODO: this needs to be discussed
    context: async ({
      req,
      res
    }) => createContext({
      sessionContext: await (sessionImplementation === null || sessionImplementation === void 0 ? void 0 : sessionImplementation.createSessionContext(req, res, createContext)),
      req
    }) // FIXME: support for apollo studio tracing
    // ...(process.env.ENGINE_API_KEY || process.env.APOLLO_KEY
    //   ? { tracing: true }
    //   : {
    //       engine: false,
    //       // Only enable tracing in dev mode so we can get local debug info, but
    //       // don't bother returning that info on prod when the `engine` is
    //       // disabled.
    //       tracing: dev,
    //     }),
    // FIXME: Support for generic custom apollo configuration
    // ...apolloConfig,

  }); // FIXME: Support custom API path via config.graphql.path.
  // Note: Core keystone uses '/admin/api' as the default.
  // FIXME: Support for file handling configuration
  // maxFileSize: 200 * 1024 * 1024,
  // maxFiles: 5,

  server.use(graphqlUploadExpress());
  apolloServer.applyMiddleware({
    app: server,
    path: '/api/graphql',
    cors: false
  });
};

const createExpressServer = async (config, system, dev) => {
  var _config$server;

  const server = express();

  if ((_config$server = config.server) !== null && _config$server !== void 0 && _config$server.cors) {
    // Setting config.server.cors = true will provide backwards compatible defaults
    // Otherwise, the user can provide their own config object to use
    const corsConfig = typeof config.server.cors === 'boolean' ? {
      origin: true,
      credentials: true
    } : config.server.cors;
    server.use(cors(corsConfig));
  }

  const sessionImplementation = config.session ? implementSession(config.session()) : undefined;
  console.log('✨ Preparing GraphQL Server');
  const {
    graphQLSchema,
    createContext
  } = system;
  addApolloServer({
    server,
    graphQLSchema,
    createContext,
    sessionImplementation
  });
  console.log('✨ Preparing Next.js app');
  server.use(await createAdminUIServer(config.ui, system, dev, sessionImplementation));
  return server;
};

let printEnumTypeDefinition = node => {
  return `export type ${node.name.value} =\n${node.values.map(x => `  | ${JSON.stringify(x.name.value)}`).join('\n')};`;
};

function printInputTypesFromSchema(schema, schemaObj, scalars) {
  let ast = parse(schema);

  let printTypeNodeWithoutNullable = node => {
    if (node.kind === 'ListType') {
      return `ReadonlyArray<${printTypeNode(node.type)}>`;
    }

    let name = node.name.value;

    if (schemaObj.getType(name) instanceof GraphQLScalarType) {
      if (scalars[name] === undefined) {
        return 'any';
      }

      return `Scalars[${JSON.stringify(name)}]`;
    }

    return name;
  };

  let printTypeNode = node => {
    if (node.kind === 'NonNullType') {
      return printTypeNodeWithoutNullable(node.type);
    }

    return `${printTypeNodeWithoutNullable(node)} | null`;
  };

  let printInputObjectTypeDefinition = node => {
    var _node$fields;

    let str = `export type ${node.name.value} = {\n`;
    (_node$fields = node.fields) === null || _node$fields === void 0 ? void 0 : _node$fields.forEach(node => {
      str += `  readonly ${node.name.value}${node.type.kind === 'NonNullType' || node.defaultValue ? '' : '?'}: ${printTypeNode(node.type)};\n`;
    });
    str += '};';
    return str;
  };

  let typeString = 'type Scalars = {\n';

  for (let scalar in scalars) {
    typeString += `  readonly ${scalar}: ${scalars[scalar]};\n`;
  }

  typeString += '};';

  for (const node of ast.definitions) {
    if (node.kind === 'InputObjectTypeDefinition') {
      typeString += '\n\n' + printInputObjectTypeDefinition(node);
    }

    if (node.kind === 'EnumTypeDefinition') {
      typeString += '\n\n' + printEnumTypeDefinition(node);
    }
  }

  return {
    printedTypes: typeString + '\n',
    ast,
    printTypeNode
  };
}

function printGeneratedTypes(printedSchema, keystone, graphQLSchema) {
  let scalars = {
    ID: 'string',
    Boolean: 'boolean',
    String: 'string',
    Int: 'number',
    Float: 'number',
    JSON: 'import("@keystone-next/types").JSONValue'
  };
  let {
    printedTypes,
    ast,
    printTypeNode
  } = printInputTypesFromSchema(printedSchema, graphQLSchema, scalars);
  printedTypes += '\n';
  let allListsStr = '\nexport type KeystoneListsTypeInfo = {';
  let queryTypeName = graphQLSchema.getQueryType().name;
  let queryNode = ast.definitions.find(node => {
    return node.kind === 'ObjectTypeDefinition' && node.name.value === queryTypeName;
  });

  if (!queryNode) {
    throw new Error('Query type on GraphQL schema not found when generating types');
  }

  let queryNodeFieldsByName = {};

  for (const field of queryNode.fields) {
    queryNodeFieldsByName[field.name.value] = field;
  }

  let printArgs = args => {
    let types = '{\n';

    for (const arg of args) {
      if (arg.name.value === 'search' || arg.name.value === 'orderBy') continue;
      types += `  readonly ${arg.name.value}${arg.type.kind === 'NonNullType' || arg.defaultValue ? '' : '?'}: ${printTypeNode(arg.type)};\n`;
    }

    return types + '}';
  };

  for (const listKey in keystone.lists) {
    const list = keystone.lists[listKey];
    let backingTypes = '{\n';

    for (const field of list.fields) {
      for (const [key, {
        optional,
        type
      }] of Object.entries(field.getBackingTypes())) {
        backingTypes += `readonly ${JSON.stringify(key)}${optional ? '?' : ''}: ${type};\n`;
      }
    }

    backingTypes += '}';
    const {
      gqlNames
    } = list;
    let listTypeInfoName = `${listKey}ListTypeInfo`;
    printedTypes += `
export type ${listTypeInfoName} = {
  key: ${JSON.stringify(listKey)};
  fields: ${Object.keys(list.fieldsByPath).map(x => JSON.stringify(x)).join('|')}
  backing: ${backingTypes};
  inputs: {
    where: ${gqlNames.whereInputName};
    create: ${gqlNames.createInputName};
    update: ${gqlNames.updateInputName};
  };
  args: {
    listQuery: ${printArgs(queryNodeFieldsByName[gqlNames.listQueryName].arguments)}
  };
};

export type ${listKey}ListFn = (
  listConfig: import('@keystone-next/keystone/schema').ListConfig<${listTypeInfoName}, ${listTypeInfoName}['fields']>
) => import('@keystone-next/keystone/schema').ListConfig<${listTypeInfoName}, ${listTypeInfoName}['fields']>;
`;
    allListsStr += `\n  readonly ${JSON.stringify(listKey)}: ${listTypeInfoName};`;
  }

  return printedTypes + allListsStr + '\n};\n';
}

const CONFIG_PATH = path.join(process.cwd(), 'keystone'); // TODO: Read port from config or process args

const PORT = process.env.PORT || 3000;

const devLoadingHTMLFilepath = path.join(path.dirname(require.resolve('@keystone-next/keystone/package.json')), 'src', 'static', 'dev-loading.html');
const formatSource = (src, parser = 'babel') => prettier.format(src, {
  parser,
  trailingComma: 'es5',
  singleQuote: true
});
const dev = async () => {
  console.log('🤞 Starting Keystone');
  const server = express();
  let expressServer = null;

  const initKeystone = async () => {
    const config = initConfig(requireSource(CONFIG_PATH).default);
    const system = createSystem(config);
    let printedSchema = printSchema(system.graphQLSchema);
    console.log('✨ Generating Schema');
    await outputFile('./.keystone/schema.graphql', printedSchema);
    await outputFile('./.keystone/schema-types.ts', formatSource(printGeneratedTypes(printedSchema, system.keystone, system.graphQLSchema), 'babel-ts'));
    console.log('✨ Connecting to the Database');
    await system.keystone.connect();
    console.log('✨ Generating Admin UI');
    await generateAdminUI(config, system);
    expressServer = await createExpressServer(config, system, true);
    console.log(`👋 Admin UI Ready`);
  };

  server.use('/__keystone_dev_status', (req, res) => {
    res.json({
      ready: expressServer ? true : false
    });
  });
  server.use((req, res, next) => {
    if (expressServer) return expressServer(req, res, next);
    res.sendFile(devLoadingHTMLFilepath);
  });
  server.listen(PORT, err => {
    if (err) throw err;
    console.log(`⭐️ Dev Server Ready on http://localhost:${PORT}`); // Don't start initialising Keystone until the dev server is ready,
    // otherwise it slows down the first response significantly

    initKeystone().catch(err => {
      console.error(`🚨 There was an error initialising Keystone`);
      console.error(err);
      process.exit(1);
    });
  });
};

async function build() {
  const config = initConfig(requireSource(CONFIG_PATH).default);
  const system = createSystem(config);
  let printedSchema = printSchema(system.graphQLSchema);
  console.log('✨ Generating Schema');
  await outputFile('./.keystone/schema.graphql', printedSchema);
  await outputFile('./.keystone/schema-types.ts', formatSource(printGeneratedTypes(printedSchema, system.keystone, system.graphQLSchema), 'babel-ts'));
  console.log('✨ Generating Admin UI');
  await generateAdminUI(config, system);
  console.log('✨ Building Admin UI and API');
  await buildAdminUI(path.resolve('.keystone'));
}

const start = async () => {
  console.log('🤞 Starting Keystone');
  const apiFile = path.resolve('./.keystone/admin/.next/server/pages/api/__keystone_api_build.js');

  if (!existsSync(apiFile)) {
    throw new Error('keystone-next build must be run before running keystone-next start');
  }

  const config = initConfig(require(apiFile).config);
  const system = createSystem(config);
  console.log('✨ Connecting to the Database');
  await system.keystone.connect();
  const server = await createExpressServer(config, system, false);
  console.log(`👋 Admin UI Ready`);
  server.listen(PORT, err => {
    if (err) throw err;
    console.log(`⭐️ Server Ready on http://localhost:${PORT}`);
  });
};

const commands = {
  dev,
  build,
  start
};
function cli(input, helpText) {
  const command = input[0] || 'dev';

  if (!(command in commands)) {
    console.log(`${command} is not a command that keystone-next accepts`);
    console.log(helpText);
    process.exit(1);
  }

  commands[command]();
}

const {
  input,
  help
} = meow(`
  Usage
    $ keystone-next [command]
  Commands
    dev          start the project in development mode
    build        build the project (must be done before using start)
    start        start the project in production mode
  `);
cli(input, help);
